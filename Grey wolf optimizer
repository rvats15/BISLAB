import numpy as np

# ------------------------------
# Grey Wolf Optimizer (GWO)
# ------------------------------
def gwo(obj_func, dim, search_space, n_agents=20, max_iter=100):
    lb, ub = search_space
    wolves = np.random.uniform(lb, ub, (n_agents, dim))
    alpha, beta, delta = None, None, None
    alpha_score, beta_score, delta_score = float("inf"), float("inf"), float("inf")

    for t in range(max_iter):
        for i in range(n_agents):
            fitness = obj_func(wolves[i])
            if fitness < alpha_score:
                delta_score, delta = beta_score, beta
                beta_score, beta = alpha_score, alpha
                alpha_score, alpha = fitness, wolves[i].copy()
            elif fitness < beta_score:
                delta_score, delta = beta_score, beta
                beta_score, beta = fitness, wolves[i].copy()
            elif fitness < delta_score:
                delta_score, delta = fitness, wolves[i].copy()

        a = 2 - 2 * (t / max_iter)
        for i in range(n_agents):
            for j in range(dim):
                r1, r2 = np.random.rand(), np.random.rand()
                A1, C1 = 2 * a * r1 - a, 2 * r2
                D_alpha = abs(C1 * alpha[j] - wolves[i][j])
                X1 = alpha[j] - A1 * D_alpha

                r1, r2 = np.random.rand(), np.random.rand()
                A2, C2 = 2 * a * r1 - a, 2 * r2
                D_beta = abs(C2 * beta[j] - wolves[i][j])
                X2 = beta[j] - A2 * D_beta

                r1, r2 = np.random.rand(), np.random.rand()
                A3, C3 = 2 * a * r1 - a, 2 * r2
                D_delta = abs(C3 * delta[j] - wolves[i][j])
                X3 = delta[j] - A3 * D_delta

                wolves[i][j] = np.clip((X1 + X2 + X3) / 3, lb, ub)

    return alpha, alpha_score


# ------------------------------
# Path Planning Environment
# ------------------------------
grid_size = (20, 20)
start, goal = np.array([0, 0]), np.array([19, 19])

# Obstacles (rectangles: x1,y1,x2,y2)
obstacles = [
    (5, 5, 10, 10),
    (12, 0, 14, 14),
    (3, 15, 15, 17)
]

def is_collision(point):
    x, y = point.astype(int)
    if x < 0 or y < 0 or x >= grid_size[0] or y >= grid_size[1]:
        return True
    for ox1, oy1, ox2, oy2 in obstacles:
        if ox1 <= x <= ox2 and oy1 <= y <= oy2:
            return True
    return False


# ------------------------------
# Objective Function
# ------------------------------
def path_cost(waypoints):
    waypoints = waypoints.reshape(-1, 2)
    path = [start] + [w.astype(int) for w in waypoints] + [goal]

    total_dist, penalty = 0, 0
    for i in range(len(path) - 1):
        dist = np.linalg.norm(path[i + 1] - path[i])
        total_dist += dist
        if is_collision(path[i + 1]):
            penalty += 100  # Big penalty for hitting obstacle

    # Energy = number of turns
    energy = 0
    for i in range(1, len(path) - 1):
        v1 = path[i] - path[i - 1]
        v2 = path[i + 1] - path[i]
        if np.linalg.norm(v1) > 0 and np.linalg.norm(v2) > 0:
            cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
            angle = np.arccos(np.clip(cos_angle, -1, 1))
            energy += angle

    return total_dist + energy * 5 + penalty


# ------------------------------
# Run GWO
# ------------------------------
n_waypoints = 5  # intermediate waypoints
dim = n_waypoints * 2
best_path, best_score = gwo(path_cost, dim, (0, grid_size[0]-1), n_agents=30, max_iter=200)

best_waypoints = best_path.reshape(-1, 2).astype(int)
final_path = np.vstack([start, best_waypoints, goal])

# ------------------------------
# Clean Path (remove duplicates + cast to int)
# ------------------------------
clean_path = []
for p in final_path:
    pt = tuple(map(int, p))
    if len(clean_path) == 0 or pt != clean_path[-1]:
        clean_path.append(pt)

# ------------------------------
# Print Results
# ------------------------------
print("Best Path Found:")
for p in clean_path:
    print(p)
print("\nPath Cost:", round(best_score, 2))
